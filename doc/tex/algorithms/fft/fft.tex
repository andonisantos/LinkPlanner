%\documentclass[a4paper]{article}
%\usepackage[top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry}
%\usepackage{amsmath}
%\usepackage{multicol}
%\usepackage{graphicx}
%\usepackage{subfig}
%\usepackage{amssymb}
%%\RequirePackage{ltxcmds}[2010/12/07]
%%opening
%\title{Linear Filtering in Frequency-Domain}
%\author{ }
%\date{ }
%\begin{document}
%
%\maketitle
\clearpage
\section{FFT}
%\subsubsection{Definitions of DFT and IDFT}
%The discrete Fourier transform of a sequence of N complex number $x_0, x_1, x_2,...,x_{N-1}$ into another sequance of complex number $X_0, X_1, X_2,...,X_{N-1}$ defined by,
%\begin{equation}
%X_k = \sum\limits_{n=0}^{N-1} x_n \cdot e^{-i2\pi kn/N}		\hspace{2cm}	0\leq k \leq N-1 
%\end{equation}
%Similarly, inverse discrete Fourier transform can be given as,
%\begin{equation}
%x_n = \frac{1}{N} \sum\limits_{n=0}^{N-1} X_k \cdot e^{i2\pi kn/N}		\hspace{2cm}	0\leq k \leq N-1 
%\end{equation}
%Using these equation, it requires $N^2$ calculation for the transformation from time domain to frequency domain and vice-versa. Therefore, it is not efficient for the practical implementation purpose. Radix-2 based FFT calculation reduces the number of computation to $Nlog n$.

\subsubsection{Algorithm}
An alternate representation of the Fourier transform can give a flexibility to utilize the same code for the FFT and IFFT with appropriate input arguments. The algorithm for the FFT will follow the following formula,
\begin{equation}
X_k =\frac{1}{\sqrt{N}} \sum\limits_{n=0}^{N-1} x_n \cdot e^{-i2\pi kn/N}		\hspace{2cm}	0\leq k \leq N-1 
\label{FFT}
\end{equation}
Similarly, for IFFT,
\begin{equation}
x_n =\frac{1}{\sqrt{N}} \sum\limits_{n=0}^{N-1} X_k \cdot e^{i2\pi kn/N}		\hspace{2cm}	0\leq k \leq N-1 
\label{IFFT}
\end{equation}
From the above manipulation discussed in equations \ref{FFT} and \ref{IFFT}, we can write only one script for the implementations Fourier algorithm and manipulate its functionality as a FFT or IFFT by applying an appropriate input arguments. \\
The generalized form for the algorithm can be given as,
\begin{equation}
OUT =\frac{1}{\sqrt{N}} \sum\limits_{n=0}^{N-1} IN \cdot e^{s \cdot i2\pi kn/N}		\hspace{2cm}	0\leq k \leq N-1 
\label{FT}
\end{equation}
where,\\
$IN \rightarrow$ {Input complex signal}\\
$OUT \rightarrow$ {Output complex signal} \& $s \rightarrow$ {'-1' for FFT and '1' for IFFT}\\

\subsubsection{Function description}
To perform FFT operation, the input argument to the function can be given as follows,
\begin{equation*}
OUT = transform(IN,-1)
\end{equation*}
in a similar way, IFFT can be manipulated as,
\begin{equation*}
OUT = transform(IN,1)
\end{equation*}

\newpage
% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=white!20, 
text width=9em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=white!20, 
text width=15em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=white!20, node distance=3cm,
minimum height=3em]

\subsubsection{Flowchart}
This algorithm converts time domain signal to frequency domain for both real and complex signal type. In case of real signal, we have to manipulate imaginary part to be zero for the execution of algorithm.
The figure \ref{Top_level_FFT } displays top level architecture of the FFT algorithm.  If the length of the input signal is $2^N$, then it'll execute Radix-2 algorithm otherwise it'll execute Bluestein algorithm.

\begin{center}
\begin{figure}[ht]

\begin{center}
\begin{tikzpicture}[node distance = 2cm, auto]
%Place nodes
\node [block] (input) { INPUT $(Real$ or $Complex)$\\sign $(-1$ or $1)$};
\node [block, below of=input, node distance=2.2cm] (n) {n = Length of INPUT};
\node [decision, below of=n, node distance=3.25cm] (decide) {Check if $n=2^N$ };
\node [block, right of=decide, node distance=5.5cm] (Bluestein) {Execute Bluestein algorithm};
\node [block, below of=decide, node distance=3.25cm] (Radix-2) {Execute Radix-2 algorithm};
\node [block, below of=Radix-2, node distance=2.2cm] (output)  { OUTPUT $(Complex)$};
%% Draw edges
\path [line] (input) -- (n);
\path [line] (n) -- (decide);
\path [line] (decide) -- node [near start] {No} (Bluestein);
\path [line] (decide) -- node [near start] {yes} (Radix-2);
\path [line] (Radix-2) -- (output);
\path [line] (Bluestein) |- (output);
\end{tikzpicture}
\end{center}
\vspace{0.5cm}
\caption{Top level architecture of the FFT algorithm}
\label{Top_level_FFT }
\end{figure}
\end{center}

\newpage
\subsubsection{Radix-2 algorithm}
The architecture of the algorithm is to accept time domain complex signal and generate frequency domain complex output signal. In the case of real input signal, first we have to convert it into the complex form by adding zero to the imaginary part. 

\begin{center}
\begin{figure}[ht]
	
	\begin{center}
		\begin{tikzpicture}[node distance = 2cm, auto]
		%Place nodes
		\node [block] (input) { INPUT $(Complex)$};
		\node [block, below of=input, node distance=2.2cm] (levels) { Compute levels N \\ $N=floor(log2(n))$};
		\node [cloud, right of=levels, node distance=7cm] (length) {n = length of input signal};
		
		\node [block, below of=levels, node distance=2.2cm] (TrignometricTable) {Generate Trignometric Tables\\$cos Table = cos(2\pi i/n)$ \\$sin Table = sin(2\pi i/n)$};
		\node [cloud, right of=TrignometricTable, node distance=7cm] (i) {where value of i=0 to n-1};
			
		\node [block, below of=TrignometricTable, node distance=2.2cm] (sequencing) {Bit-reversed permutation\\$Even-Odd$ $seperation$};
		\node [block, below of=sequencing, node distance=2.2cm] (CT) {Cooley-Tukey algorithm\\$DIT$ $Radix-2$ $FFT$};
		\node [block,below of=CT, node distance=2.2cm] (output) { OUTPUT $(Complex)$};
%		\node [block, below of=input, node distance=3cm] (n) {n = Length of the input signal};
%		\node [decision, below of=n, node distance=4cm] (decide) {Check if $n=2^N$ };
%		\node [block, right of=decide, node distance=6cm] (Bluestein) {Execute Bluestein algorithm};
%		\node [block, below of=decide, node distance=4cm] (Radix-2) {Execute Radix-2 algorithm};
%		%% Draw edges
		\path [line] (input) -- (levels);
		\path [line] (levels) -- (TrignometricTable);
		\path [line] (levels) -- (length);
		\path [line] (TrignometricTable) -- (sequencing);
		\path [line] (TrignometricTable) -- (i);
		\path [line] (sequencing) -- (CT);
		\path [line] (CT) -- (output);
%		\path [line] (n) -- (decide);
%		\path [line] (decide) -- node [near start] {No} (Bluestein);
%		\path [line] (decide) -- node [near start] {yes} (Radix-2);
		\end{tikzpicture}
	\end{center}
	\vspace{0.5cm}
	\caption{Flowchart of Cooly-Tukey DIT Radix-2 algorithm}
	\label{ }
\end{figure}
\end{center}

\newpage
\subsubsection{Bluestein algorithm}

\begin{center}
	\begin{figure}[ht]
		
		\begin{center}
			\begin{tikzpicture}[node distance = 2cm, auto]
			%Place nodes
			\node [block] (input) {INPUT $Complex$};
			\node [block, below of=input, node distance=2.2cm] (length) {Calculate a power-of-2 convolution length $m$};
				\node [cloud, right of=length, node distance=5.35cm] (m) {$m\geq2n+1$};	
			\node [block, below of=length, node distance=2.2cm] (TrignometricTable) { Generate Trignometric Tables
			\\$cos Table = cos(\pi\cdot i\cdot i/n)$ \\$sin Table = sin(\pi\cdot i\cdot i/n)$};
			 	\node [cloud, right of=TrignometricTable, node distance=7cm] (i) {where value of i=0 to n-1};
			\node [block, below of=TrignometricTable, node distance=2.2cm] (preprocessing) {Temporary vectors and preprocessing}; 
			\node [block, below of=preprocessing, node distance=2.2cm] (convolution) {Convolution};
			\node [block, below of=convolution, node distance=2.2cm] (postprocessing) {Postprocessing}; 
			
			\node [block,below of=postprocessing, node distance=2.2cm] (output) { OUTPUT $Complex$};
			 
%			% Draw edges
			\path [line] (input) -- (length);
			\path [line] (levels) -- (TrignometricTable);
			\path [line] (levels) -- (m);
			\path [line] (TrignometricTable) -- (preprocessing);
			\path [line] (TrignometricTable) -- (i);
			\path [line] (preprocessing) -- (convolution);
			\path [line] (convolution) -- (postprocessing);
			\path [line] (postprocessing) -- (output);
%			\path [line] (CT) -- (output);
%			%		\path [line] (n) -- (decide);
%			%		\path [line] (decide) -- node [near start] {No} (Bluestein);
%			%		\path [line] (decide) -- node [near start] {yes} (Radix-2);
			\end{tikzpicture}
		\end{center}
		\vspace{0.5cm}
		\caption{Flowchart of Bluestein algorithm}
		\label{ }
	\end{figure}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Example flowchart START %%%%%%%%%%%%%%%%%
%\tikzstyle{decision} = [diamond, draw, fill=blue!20, 
%text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
%\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
%text width=5em, text centered, rounded corners, minimum height=4em]
%\tikzstyle{line} = [draw, -latex']
%\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
%minimum height=2em]
%\begin{tikzpicture}[node distance = 2cm, auto]
%% Place nodes
%\node [block] (init) {initialize model};
%\node [cloud, left of=init] (expert) {expert};
%\node [cloud, right of=init] (system) {system};
%\node [block, below of=init] (identify) {identify candidate models};
%\node [block, below of=identify] (evaluate) {evaluate candidate models};
%\node [block, left of=evaluate, node distance=3cm] (update) {update model};
%\node [decision, below of=evaluate] (decide) {is best candidate better?};
%\node [block, below of=decide, node distance=3cm] (stop) {stop};
%% Draw edges
%%\path [line] (init) -- (identify);
%\path [line] (identify) -- (evaluate);
%\path [line] (evaluate) -- (decide);
%\path [line] (decide) -| node [near start] {yes} (update);
%\path [line] (update) |- (identify);
%\path [line] (decide) -- node {no}(stop);
%\path [line,dashed] (expert) -- (init);
%\path [line,dashed] (system) -- (init);
%\path [line,dashed] (system) |- (evaluate);
%\end{tikzpicture}
%%%%%%%%%%% Example flowchart END %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\end{document}

